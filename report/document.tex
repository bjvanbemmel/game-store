\documentclass[a4paper]{report}
\usepackage[dutch]{babel}
\usepackage[backend=biber,style=apa]{biblatex}
\addbibresource{citations.bib}
\usepackage{csquotes}
\usepackage{lmodern}
\usepackage{listings}
\lstdefinestyle{css}{%
    xleftmargin={0.75cm},
    numbers=left,
    stepnumber=1,
    firstnumber=1,
    numberfirstline=true,
    tabsize=4,
    showtabs=false,
    showspaces=false,
    showstringspaces=false,
    extendedchars=true,
    breaklines=true,
    frame=single,
}
\renewcommand{\familydefault}{\sfdefault}

\title{Front-end keuzedeel eindverslag}
\author{Beau Jean van Bemmel, 97085143}
\begin{document}
    \maketitle

    \chapter*{Voorwoord}
    \pagenumbering{gobble}
    Dit verslag gaat ervan uit dat de lezer al wat basis kennis heeft op het gebied van web development.
    Zo wordt er hier en daar vakterminologie gebruikt. Bij elke eerste instantie van zo'n woord is er ook een referentie te vinden naar een externe bron.
    Aan het einde van dit document vindt u ook een bibliografie met alle gebruikte bronnen.

    Ik hoop met dit verslag wat inspiratie te kunnen creëren bij de lezer(s) om ook op pad te gaan en een nieuw framework te leren en toe te passen.
    Er is niets belangrijker voor een software developer dan de vaardigheid om uit zijn of haar comfort-zone te kunnen kruipen.
    \tableofcontents

    \chapter{Inleiding}
    \pagenumbering{arabic}
    De afgelopen twéé maanden ben ik bezig geweest met het \textit{front-end development} keuzedeel.
    Gedurende deze periode heb ik o.a. veel kennis opgedaan van 
    \textit{Nuxt}\footfullcite{nuxt}, een 
    \textit{meta-framework}\footfullcite{meta} voor 
    \textit{Vue.js}\footfullcite{vue}.
    
    Naast het gebruiken van een front-end framework heb ik er ook voor gekozen om een \textit{Application Programming Interface (API)}\footfullcite{api} te bouwen en gebruiken.
    Deze API heb ik gemaakt met \textit{Go}\footfullcite{go}. Meer over deze beslissing en de uitwerking hiervan vindt u in een later hoofdstuk.

    In de volgende hoofdstukken vertel ik u graag over de keuzes die ik heb moeten maken, de situaties waarin ik vast liep en de ontdekkingen die ik heb gemaakt.

    \chapter{Gebruikte technologieën}
    Voordat we beginnen met de SEO en toegankelijkheidsrapportages wil ik even een moment nemen om mijn \textit{tech stack} te introduceren.
    Dit houdt in de talen, frameworks, libraries en diverse tools waar ik gebruik van heb gemaakt gedurende de ontwikkeling van dit keuzedeel:

    \section{TypeScript}
    Om te beginnen wil ik de meest belangrijke taal in deze \textit{stack} introduceren: \textit{TypeScript}\footfullcite{ts}.
    Aan het begin van dit keuzedeel heb ik de keuze gemaakt om in plaats van het normale \textit{JavaScript} gebruik te maken van TypeScript.
    De reden hiervoor is omdat ik een groot fan ben van types. Het maakt code veel voorspelbaarder en ook makkelijker te lezen.
    Een ander groot pluspunt is het feit dat de \textit{Language Server Protocol (LSP)}\footfullcite{lsp} enorm fijn meewerkt met een typed taal.

    De laatste maanden ben ik veel bezig geweest met PHP (in combinatie met Laravel), C\# en Go. Één ding dat al deze talen en frameworks met elkaar gemeen hebben
    is dat ze gebruik maken van types. PHP heeft tegenwoordig strict typing. Sinds dit is uitgekomen maakt Laravel gebruik van strict typing op alle APIs die in aanraking komen met de developer.
    C\# en Go zijn ook beiden typed talen. Geen hebben een optie om dynamisch te werken (enige vergelijkbare punt is dat ze beiden \textit{type inference} hebben, dus hoef je niet alles zelf aan te geven).

    Sinds ik gewend ben geraakt aan het werken met strict typing vond ik het een wijze keuze om dit ook in het JavaScript ecosysteem toe te passen met TypeScript.
    Met mijn bestaande kennis van \textit{interfaces} en \textit{enums} heb ik veel leuke trucjes uit weten te voeren om solide, veilige en toch uitbreidbare code te schrijven.

    \section{Go}
    Aan het begin van dit keuzedeel heb ik nog een andere bijzondere beslissing gemaakt: Het bouwen van een API.
    Het klinkt misschien gek om voor een front-end keuzedeel ook de focus te gooien op back-end, maar de reden hiervoor was uiteindelijk heel simpel:
    Ik wilde graag een dynamische website maken die ook met zoekopdrachten zou werken. Hiervoor kun ik uiteraard gewoon een JSON mokken en uiteindelijk via JS op arrays filteren,
    maar ik vond het leuker om echt te werken met een API.
    Ook vond ik het een mooie kans om een API te bouwen met Go, sinds ik dat nog niet vaak gedaan had. Wanneer je de code van dit project ziet, dan lijkt het wel alsof de focus
    op de back-end lag. Dit komt omdat de root van dit project eigenlijk een Go project-structuur heeft. Het Nuxt project bevindt zich in een sub-directory genaamd ''web``.
    Nu moet ik toegeven dat ik deze back-end drie keer opnieuw heb geschreven. Uiteraard betekent dit dat ik veel heb geleerd op niet alleen de front-end kant, maar ook de back-end.
    Achteraf blijkt het dus wel een goede beslissing te zijn om een back-end te hebben gebouwd met Go. Dit heeft de front-end ook mooier gemaakt, omdat ik zoekfuncties en laad-animaties heb kunnen toevoegen.

    \section{Nuxt}
    Ik had voor Nuxt gekozen, omdat dit framework met \textit{Server Side Rendering (SSR)} komt.
    Dit houdt in dat de HTML op de server gegenereerd wordt i.p.v. op de client. De aanwezigheid van SSR maakt het bot vriendelijk - om het zo even te noemen.

    Nu maakt Nuxt niet alleen maar gebruik van SSR. Feitelijk maakt het gebruik van \textit{Universal Rendering}\footfullcite{universal}.
    Dat wil betekenen dat op de \textit{initial page load} - het moment dat de pagina voor het eerst wordt ingeladen - alle HTML gegenereerd wordt door de server
    en verstuurd wordt naar de client. Naast deze HTML wordt ook een lading \textit{JavaScript (JS)} meegestuurd. Deze JS neemt het hierna over en maakt van de applicatie een
    \textit{Single-page application (SPA)}\footfullcite{spa}.

    Nuxt maakt gebruik van de Vue.js \textit{templating engine}. Ik had al ervaring met Vue.js, dus was het niet enorm lastig om te wennen aan Nuxt.
    Door Nuxt te gebruiken ontvang je allerlei ingebouwde functionaliteiten, zoals:
    \textit{State Management}\footfullcite{state},
    \textit{Automatic Imports}\footfullcite{autoimports},
    \textit{File-based Routing}\footfullcite{routing}
    en andere functies waar ik geen gebruik van heb gemaakt.

    \section{Tailwind}
    Bij een front-end opdracht hoort HTML, en bij HTML hoort CSS.
    Al hoewel ik voldoende ervaring heb met het schrijven van CSS, vind ik het een vervelende taal om mee te werken.
    Het creëert een gigantische lijst aan korte \textit{key:value} pairs, die allemaal gelinkt zijn aan een element, class of id - soms ook met speciale selectors.
    Zo'n CSS bestand gaat al snel de duizenden lijnen in bij een applicatie van gemiddelde grootte. Nu biedt Vue.js (en daarbij dus ook Nuxt) de mogelijkheid aan om
    \textit{scoped CSS}\footfullcite{scopedcss} te gebruiken. Helaas verhelpt dit niet het probleem dat je een gigantische lijst met korte lijnen krijgt.
    Uiteraard kun je de CSS minimaliseren, maar dan wordt het nog onleesbaarder en lastiger te navigeren voor de developer.

    Van dit probleem hebben meerdere mensen last, daarom bestaat er een CSS library genaamd \textit{Tailwind CSS}\footfullcite{tailwind}.

    Het idee van Tailwind is dat alle mogelijke styling options een eigen class hebben. Wat volgt is een klein voorbeeld van vanilla CSS vergeleken met Tailwind classes.
    \begin{lstlisting}[caption={Een Flexbox container met een zwarte rand in vanilla CSS}, label=useless, style=css]
    .container {
        display: flex;
        justify-content: center;
        align-items: center;
        border: .1rem solid black;
    }
    \end{lstlisting}
    \begin{lstlisting}[caption={Dezelfde container geschreven in Tailwind}, label=useless, style=css]
    <div
        class="flex justify-center items-center border-1 border-black"
    ></div>
    \end{lstlisting}

    In het begin zal dit misschien als een slechte oplossing lijken. Zo creëer je namelijk i.p.v. een gigantische lijst aan korte lijnen een grote lijst met classes.
    Dit klopt in principe ook, maar in de praktijk zult u zien dat het een verbetering is op standaard CSS. Alle styling wordt gedefinieerd exact waar het nodig is.
    Zo hoef je dus niet steeds twee bestanden met elkaar te vergelijken. Hierdoor is het in één oogopslag duidelijk hoe een HTML element eruit komt te zien.

    Tailwind bevat ook predefined classes voor kleuren, border-radius, shadow etc. Zo kunt u bijvoorbeeld {\fontfamily{courier}\selectfont bg-red-500} gebruiken
    om een hoog contrast rood te krijgen. Tailwind kent dus een groot hoeveelheid classes die gecureerde styling bevatten. Niet op het niveau als
    \textit{Bootstrap}\footfullcite{bootstrap}, waar kant en klare buttons bestaan, maar op vorm en kleur niveau. Dit geeft een developer de flexibiliteit van vanilla CSS
    met het gemak van Bootstrap.

    \section{Docker}
    Ik codeer op twéé verschillende apparaten: mijn laptop en desktop PC. Welk apparaat ik gebruik hangt af van mijn locatie.
    Nu kunt u zich misschien wel voorstellen dat ik het zo makkelijk mogelijk wil maken voor mijzelf om te kunnen schakelen tussen deze twéé apparaten.
    Daarom heb ik ervoor gekozen om Docker te gebruiken voor dit project. Feitelijk gebruik ik Docker voor al mijn projecten, dus was dit geen lastige beslissing om te maken.

    Docker geeft developers de mogelijkheid om op elk apparaat een identieke ontwikkelomgeving neer te zetten. Het is vergelijkbaar met \textit{virtual machines (VMs)}, maar dan
    vele malen lichter. Het grootste verschil tussen de twéé ligt hem in het feit dat VMs de hardware emuleren, waarals Docker het operatie systeem emuleert. De kernels worden
    verder dus nog wel gedeeld tussen de host en de Docker containers.

    Voor de meeste situaties is dit niveau van virtualisatie meer dan voldoende, daarom heeft bijna de gehele industrie nu al kennis gemaakt met cloud software zoals Docker.
    Binnen de code van dit project vindt u een aantal bestanden, zoals {\fontfamily{courier}\selectfont docker-compose.yml, docker/go/Dockerfile} en
    {\fontfamily{courier}\selectfont docker/node/Dockerfile}. Deze bestanden zorgen ervoor dat ik met een enkel commando mijn database, front-end en back-end op kan starten op welke omgeving dan ook.

    Docker is puur gemak, dus maak ik er graag gebruik van.

    \chapter{SEO}

    \chapter{Toegankelijkheid}

    \chapter{Verbetervoorstellen}

    \chapter{Reflectie}

    \printbibliography
\end{document}
